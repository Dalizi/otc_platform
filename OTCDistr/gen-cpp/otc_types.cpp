/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "otc_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kLongShortTypeValues[] = {
  LONG,
  SHORT
};
const char* _kLongShortTypeNames[] = {
  "LONG",
  "SHORT"
};
const std::map<int, const char*> _LongShortType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLongShortTypeValues, _kLongShortTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOpenOffsetTypeValues[] = {
  OPEN,
  OFFSET
};
const char* _kOpenOffsetTypeNames[] = {
  "OPEN",
  "OFFSET"
};
const std::map<int, const char*> _OpenOffsetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kOpenOffsetTypeValues, _kOpenOffsetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOrderStatusTypeValues[] = {
  REPORTED,
  ACCEPTED,
  REJECTED,
  CANCELED
};
const char* _kOrderStatusTypeNames[] = {
  "REPORTED",
  "ACCEPTED",
  "REJECTED",
  "CANCELED"
};
const std::map<int, const char*> _OrderStatusType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kOrderStatusTypeValues, _kOrderStatusTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ClientInfoTrans::~ClientInfoTrans() throw() {
}


void ClientInfoTrans::__set_client_name(const std::string& val) {
  this->client_name = val;
}

void ClientInfoTrans::__set_client_id(const int32_t val) {
  this->client_id = val;
}

void ClientInfoTrans::__set_interview_record(const std::string& val) {
  this->interview_record = val;
}

void ClientInfoTrans::__set_review_material(const std::string& val) {
  this->review_material = val;
}

void ClientInfoTrans::__set_public_info(const std::string& val) {
  this->public_info = val;
}

void ClientInfoTrans::__set_client_relationship(const std::string& val) {
  this->client_relationship = val;
}

void ClientInfoTrans::__set_client_level(const int16_t val) {
  this->client_level = val;
}

void ClientInfoTrans::__set_trust_value(const double val) {
  this->trust_value = val;
}

void ClientInfoTrans::__set_chartered_business(const std::string& val) {
  this->chartered_business = val;
}

const char* ClientInfoTrans::ascii_fingerprint = "323D56A11A662D65187D0BD9060B9A00";
const uint8_t ClientInfoTrans::binary_fingerprint[16] = {0x32,0x3D,0x56,0xA1,0x1A,0x66,0x2D,0x65,0x18,0x7D,0x0B,0xD9,0x06,0x0B,0x9A,0x00};

uint32_t ClientInfoTrans::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_name);
          this->__isset.client_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->interview_record);
          this->__isset.interview_record = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->review_material);
          this->__isset.review_material = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->public_info);
          this->__isset.public_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_relationship);
          this->__isset.client_relationship = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->client_level);
          this->__isset.client_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->trust_value);
          this->__isset.trust_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chartered_business);
          this->__isset.chartered_business = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientInfoTrans::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientInfoTrans");

  xfer += oprot->writeFieldBegin("client_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->client_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interview_record", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->interview_record);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("review_material", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->review_material);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("public_info", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->public_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_relationship", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->client_relationship);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_level", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->client_level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trust_value", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->trust_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chartered_business", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->chartered_business);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ClientInfoTrans &a, ClientInfoTrans &b) {
  using ::std::swap;
  swap(a.client_name, b.client_name);
  swap(a.client_id, b.client_id);
  swap(a.interview_record, b.interview_record);
  swap(a.review_material, b.review_material);
  swap(a.public_info, b.public_info);
  swap(a.client_relationship, b.client_relationship);
  swap(a.client_level, b.client_level);
  swap(a.trust_value, b.trust_value);
  swap(a.chartered_business, b.chartered_business);
  swap(a.__isset, b.__isset);
}

ClientInfoTrans::ClientInfoTrans(const ClientInfoTrans& other0) {
  client_name = other0.client_name;
  client_id = other0.client_id;
  interview_record = other0.interview_record;
  review_material = other0.review_material;
  public_info = other0.public_info;
  client_relationship = other0.client_relationship;
  client_level = other0.client_level;
  trust_value = other0.trust_value;
  chartered_business = other0.chartered_business;
  __isset = other0.__isset;
}
ClientInfoTrans& ClientInfoTrans::operator=(const ClientInfoTrans& other1) {
  client_name = other1.client_name;
  client_id = other1.client_id;
  interview_record = other1.interview_record;
  review_material = other1.review_material;
  public_info = other1.public_info;
  client_relationship = other1.client_relationship;
  client_level = other1.client_level;
  trust_value = other1.trust_value;
  chartered_business = other1.chartered_business;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ClientInfoTrans& obj) {
  using apache::thrift::to_string;
  out << "ClientInfoTrans(";
  out << "client_name=" << to_string(obj.client_name);
  out << ", " << "client_id=" << to_string(obj.client_id);
  out << ", " << "interview_record=" << to_string(obj.interview_record);
  out << ", " << "review_material=" << to_string(obj.review_material);
  out << ", " << "public_info=" << to_string(obj.public_info);
  out << ", " << "client_relationship=" << to_string(obj.client_relationship);
  out << ", " << "client_level=" << to_string(obj.client_level);
  out << ", " << "trust_value=" << to_string(obj.trust_value);
  out << ", " << "chartered_business=" << to_string(obj.chartered_business);
  out << ")";
  return out;
}


PositionTypeTrans::~PositionTypeTrans() throw() {
}


void PositionTypeTrans::__set_client_id(const int32_t val) {
  this->client_id = val;
}

void PositionTypeTrans::__set_instr_code(const std::string& val) {
  this->instr_code = val;
}

void PositionTypeTrans::__set_average_price(const double val) {
  this->average_price = val;
}

void PositionTypeTrans::__set_total_amount(const int32_t val) {
  this->total_amount = val;
}

void PositionTypeTrans::__set_available_amount(const int32_t val) {
  this->available_amount = val;
}

void PositionTypeTrans::__set_frozen_amount(const int32_t val) {
  this->frozen_amount = val;
}

void PositionTypeTrans::__set_long_short(const LongShortType val) {
  this->long_short = val;
}

void PositionTypeTrans::__set_offset_price(const double val) {
  this->offset_price = val;
}

const char* PositionTypeTrans::ascii_fingerprint = "7D2F1354CF92A9B824710F68652982FC";
const uint8_t PositionTypeTrans::binary_fingerprint[16] = {0x7D,0x2F,0x13,0x54,0xCF,0x92,0xA9,0xB8,0x24,0x71,0x0F,0x68,0x65,0x29,0x82,0xFC};

uint32_t PositionTypeTrans::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instr_code);
          this->__isset.instr_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->average_price);
          this->__isset.average_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_amount);
          this->__isset.total_amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->available_amount);
          this->__isset.available_amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frozen_amount);
          this->__isset.frozen_amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->long_short = (LongShortType)ecast2;
          this->__isset.long_short = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->offset_price);
          this->__isset.offset_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PositionTypeTrans::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("PositionTypeTrans");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instr_code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->instr_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("average_price", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->average_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_amount", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->total_amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("available_amount", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->available_amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("frozen_amount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->frozen_amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("long_short", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->long_short);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_price", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->offset_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(PositionTypeTrans &a, PositionTypeTrans &b) {
  using ::std::swap;
  swap(a.client_id, b.client_id);
  swap(a.instr_code, b.instr_code);
  swap(a.average_price, b.average_price);
  swap(a.total_amount, b.total_amount);
  swap(a.available_amount, b.available_amount);
  swap(a.frozen_amount, b.frozen_amount);
  swap(a.long_short, b.long_short);
  swap(a.offset_price, b.offset_price);
  swap(a.__isset, b.__isset);
}

PositionTypeTrans::PositionTypeTrans(const PositionTypeTrans& other3) {
  client_id = other3.client_id;
  instr_code = other3.instr_code;
  average_price = other3.average_price;
  total_amount = other3.total_amount;
  available_amount = other3.available_amount;
  frozen_amount = other3.frozen_amount;
  long_short = other3.long_short;
  offset_price = other3.offset_price;
  __isset = other3.__isset;
}
PositionTypeTrans& PositionTypeTrans::operator=(const PositionTypeTrans& other4) {
  client_id = other4.client_id;
  instr_code = other4.instr_code;
  average_price = other4.average_price;
  total_amount = other4.total_amount;
  available_amount = other4.available_amount;
  frozen_amount = other4.frozen_amount;
  long_short = other4.long_short;
  offset_price = other4.offset_price;
  __isset = other4.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const PositionTypeTrans& obj) {
  using apache::thrift::to_string;
  out << "PositionTypeTrans(";
  out << "client_id=" << to_string(obj.client_id);
  out << ", " << "instr_code=" << to_string(obj.instr_code);
  out << ", " << "average_price=" << to_string(obj.average_price);
  out << ", " << "total_amount=" << to_string(obj.total_amount);
  out << ", " << "available_amount=" << to_string(obj.available_amount);
  out << ", " << "frozen_amount=" << to_string(obj.frozen_amount);
  out << ", " << "long_short=" << to_string(obj.long_short);
  out << ", " << "offset_price=" << to_string(obj.offset_price);
  out << ")";
  return out;
}


OrderTypeTrans::~OrderTypeTrans() throw() {
}


void OrderTypeTrans::__set_instr_code(const std::string& val) {
  this->instr_code = val;
}

void OrderTypeTrans::__set_order_id(const std::string& val) {
  this->order_id = val;
}

void OrderTypeTrans::__set_date_time(const std::string& val) {
  this->date_time = val;
}

void OrderTypeTrans::__set_client_id(const int32_t val) {
  this->client_id = val;
}

void OrderTypeTrans::__set_price(const double val) {
  this->price = val;
}

void OrderTypeTrans::__set_amount(const int32_t val) {
  this->amount = val;
}

void OrderTypeTrans::__set_long_short(const LongShortType val) {
  this->long_short = val;
}

void OrderTypeTrans::__set_open_offset(const OpenOffsetType val) {
  this->open_offset = val;
}

void OrderTypeTrans::__set_order_status(const OrderStatusType val) {
  this->order_status = val;
}

const char* OrderTypeTrans::ascii_fingerprint = "44800261FBA1F6EC20D0D01E21AFBBA2";
const uint8_t OrderTypeTrans::binary_fingerprint[16] = {0x44,0x80,0x02,0x61,0xFB,0xA1,0xF6,0xEC,0x20,0xD0,0xD0,0x1E,0x21,0xAF,0xBB,0xA2};

uint32_t OrderTypeTrans::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instr_code);
          this->__isset.instr_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->order_id);
          this->__isset.order_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->date_time);
          this->__isset.date_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->long_short = (LongShortType)ecast5;
          this->__isset.long_short = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->open_offset = (OpenOffsetType)ecast6;
          this->__isset.open_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->order_status = (OrderStatusType)ecast7;
          this->__isset.order_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OrderTypeTrans::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("OrderTypeTrans");

  xfer += oprot->writeFieldBegin("instr_code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instr_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->order_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("date_time", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->date_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("long_short", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->long_short);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_offset", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->open_offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order_status", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->order_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(OrderTypeTrans &a, OrderTypeTrans &b) {
  using ::std::swap;
  swap(a.instr_code, b.instr_code);
  swap(a.order_id, b.order_id);
  swap(a.date_time, b.date_time);
  swap(a.client_id, b.client_id);
  swap(a.price, b.price);
  swap(a.amount, b.amount);
  swap(a.long_short, b.long_short);
  swap(a.open_offset, b.open_offset);
  swap(a.order_status, b.order_status);
  swap(a.__isset, b.__isset);
}

OrderTypeTrans::OrderTypeTrans(const OrderTypeTrans& other8) {
  instr_code = other8.instr_code;
  order_id = other8.order_id;
  date_time = other8.date_time;
  client_id = other8.client_id;
  price = other8.price;
  amount = other8.amount;
  long_short = other8.long_short;
  open_offset = other8.open_offset;
  order_status = other8.order_status;
  __isset = other8.__isset;
}
OrderTypeTrans& OrderTypeTrans::operator=(const OrderTypeTrans& other9) {
  instr_code = other9.instr_code;
  order_id = other9.order_id;
  date_time = other9.date_time;
  client_id = other9.client_id;
  price = other9.price;
  amount = other9.amount;
  long_short = other9.long_short;
  open_offset = other9.open_offset;
  order_status = other9.order_status;
  __isset = other9.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const OrderTypeTrans& obj) {
  using apache::thrift::to_string;
  out << "OrderTypeTrans(";
  out << "instr_code=" << to_string(obj.instr_code);
  out << ", " << "order_id=" << to_string(obj.order_id);
  out << ", " << "date_time=" << to_string(obj.date_time);
  out << ", " << "client_id=" << to_string(obj.client_id);
  out << ", " << "price=" << to_string(obj.price);
  out << ", " << "amount=" << to_string(obj.amount);
  out << ", " << "long_short=" << to_string(obj.long_short);
  out << ", " << "open_offset=" << to_string(obj.open_offset);
  out << ", " << "order_status=" << to_string(obj.order_status);
  out << ")";
  return out;
}


TransactionTypeTrans::~TransactionTypeTrans() throw() {
}


void TransactionTypeTrans::__set_instr_code(const std::string& val) {
  this->instr_code = val;
}

void TransactionTypeTrans::__set_transaction_id(const std::string& val) {
  this->transaction_id = val;
}

void TransactionTypeTrans::__set_date_time(const std::string& val) {
  this->date_time = val;
}

void TransactionTypeTrans::__set_client_id(const int32_t val) {
  this->client_id = val;
}

void TransactionTypeTrans::__set_price(const double val) {
  this->price = val;
}

void TransactionTypeTrans::__set_amount(const int32_t val) {
  this->amount = val;
}

void TransactionTypeTrans::__set_long_short(const LongShortType val) {
  this->long_short = val;
}

void TransactionTypeTrans::__set_open_offset(const OpenOffsetType val) {
  this->open_offset = val;
}

void TransactionTypeTrans::__set_underlying_price(const double val) {
  this->underlying_price = val;
}

const char* TransactionTypeTrans::ascii_fingerprint = "C13DDC9C0D9F05D1BA470A95B8798267";
const uint8_t TransactionTypeTrans::binary_fingerprint[16] = {0xC1,0x3D,0xDC,0x9C,0x0D,0x9F,0x05,0xD1,0xBA,0x47,0x0A,0x95,0xB8,0x79,0x82,0x67};

uint32_t TransactionTypeTrans::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instr_code);
          this->__isset.instr_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transaction_id);
          this->__isset.transaction_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->date_time);
          this->__isset.date_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->long_short = (LongShortType)ecast10;
          this->__isset.long_short = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->open_offset = (OpenOffsetType)ecast11;
          this->__isset.open_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->underlying_price);
          this->__isset.underlying_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionTypeTrans::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TransactionTypeTrans");

  xfer += oprot->writeFieldBegin("instr_code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instr_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transaction_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->transaction_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("date_time", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->date_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->amount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("long_short", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->long_short);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_offset", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->open_offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("underlying_price", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->underlying_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TransactionTypeTrans &a, TransactionTypeTrans &b) {
  using ::std::swap;
  swap(a.instr_code, b.instr_code);
  swap(a.transaction_id, b.transaction_id);
  swap(a.date_time, b.date_time);
  swap(a.client_id, b.client_id);
  swap(a.price, b.price);
  swap(a.amount, b.amount);
  swap(a.long_short, b.long_short);
  swap(a.open_offset, b.open_offset);
  swap(a.underlying_price, b.underlying_price);
  swap(a.__isset, b.__isset);
}

TransactionTypeTrans::TransactionTypeTrans(const TransactionTypeTrans& other12) {
  instr_code = other12.instr_code;
  transaction_id = other12.transaction_id;
  date_time = other12.date_time;
  client_id = other12.client_id;
  price = other12.price;
  amount = other12.amount;
  long_short = other12.long_short;
  open_offset = other12.open_offset;
  underlying_price = other12.underlying_price;
  __isset = other12.__isset;
}
TransactionTypeTrans& TransactionTypeTrans::operator=(const TransactionTypeTrans& other13) {
  instr_code = other13.instr_code;
  transaction_id = other13.transaction_id;
  date_time = other13.date_time;
  client_id = other13.client_id;
  price = other13.price;
  amount = other13.amount;
  long_short = other13.long_short;
  open_offset = other13.open_offset;
  underlying_price = other13.underlying_price;
  __isset = other13.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TransactionTypeTrans& obj) {
  using apache::thrift::to_string;
  out << "TransactionTypeTrans(";
  out << "instr_code=" << to_string(obj.instr_code);
  out << ", " << "transaction_id=" << to_string(obj.transaction_id);
  out << ", " << "date_time=" << to_string(obj.date_time);
  out << ", " << "client_id=" << to_string(obj.client_id);
  out << ", " << "price=" << to_string(obj.price);
  out << ", " << "amount=" << to_string(obj.amount);
  out << ", " << "long_short=" << to_string(obj.long_short);
  out << ", " << "open_offset=" << to_string(obj.open_offset);
  out << ", " << "underlying_price=" << to_string(obj.underlying_price);
  out << ")";
  return out;
}


ClientBalanceTrans::~ClientBalanceTrans() throw() {
}


void ClientBalanceTrans::__set_client_id(const int32_t val) {
  this->client_id = val;
}

void ClientBalanceTrans::__set_total_balance(const double val) {
  this->total_balance = val;
}

void ClientBalanceTrans::__set_available_balance(const double val) {
  this->available_balance = val;
}

void ClientBalanceTrans::__set_withdrawable_balance(const double val) {
  this->withdrawable_balance = val;
}

void ClientBalanceTrans::__set_occupied_margin(const double val) {
  this->occupied_margin = val;
}

const char* ClientBalanceTrans::ascii_fingerprint = "5472C7414D3514110BC82AEEAA7E60C6";
const uint8_t ClientBalanceTrans::binary_fingerprint[16] = {0x54,0x72,0xC7,0x41,0x4D,0x35,0x14,0x11,0x0B,0xC8,0x2A,0xEE,0xAA,0x7E,0x60,0xC6};

uint32_t ClientBalanceTrans::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->total_balance);
          this->__isset.total_balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->available_balance);
          this->__isset.available_balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->withdrawable_balance);
          this->__isset.withdrawable_balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->occupied_margin);
          this->__isset.occupied_margin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientBalanceTrans::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientBalanceTrans");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_balance", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->total_balance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("available_balance", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->available_balance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withdrawable_balance", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->withdrawable_balance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("occupied_margin", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->occupied_margin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ClientBalanceTrans &a, ClientBalanceTrans &b) {
  using ::std::swap;
  swap(a.client_id, b.client_id);
  swap(a.total_balance, b.total_balance);
  swap(a.available_balance, b.available_balance);
  swap(a.withdrawable_balance, b.withdrawable_balance);
  swap(a.occupied_margin, b.occupied_margin);
  swap(a.__isset, b.__isset);
}

ClientBalanceTrans::ClientBalanceTrans(const ClientBalanceTrans& other14) {
  client_id = other14.client_id;
  total_balance = other14.total_balance;
  available_balance = other14.available_balance;
  withdrawable_balance = other14.withdrawable_balance;
  occupied_margin = other14.occupied_margin;
  __isset = other14.__isset;
}
ClientBalanceTrans& ClientBalanceTrans::operator=(const ClientBalanceTrans& other15) {
  client_id = other15.client_id;
  total_balance = other15.total_balance;
  available_balance = other15.available_balance;
  withdrawable_balance = other15.withdrawable_balance;
  occupied_margin = other15.occupied_margin;
  __isset = other15.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ClientBalanceTrans& obj) {
  using apache::thrift::to_string;
  out << "ClientBalanceTrans(";
  out << "client_id=" << to_string(obj.client_id);
  out << ", " << "total_balance=" << to_string(obj.total_balance);
  out << ", " << "available_balance=" << to_string(obj.available_balance);
  out << ", " << "withdrawable_balance=" << to_string(obj.withdrawable_balance);
  out << ", " << "occupied_margin=" << to_string(obj.occupied_margin);
  out << ")";
  return out;
}


GreekRisk::~GreekRisk() throw() {
}


void GreekRisk::__set_delta(const double val) {
  this->delta = val;
}

void GreekRisk::__set_gamma(const double val) {
  this->gamma = val;
}

void GreekRisk::__set_theta(const double val) {
  this->theta = val;
}

void GreekRisk::__set_vega(const double val) {
  this->vega = val;
}

const char* GreekRisk::ascii_fingerprint = "D40B774F31F5CC6330E604960421B6CB";
const uint8_t GreekRisk::binary_fingerprint[16] = {0xD4,0x0B,0x77,0x4F,0x31,0xF5,0xCC,0x63,0x30,0xE6,0x04,0x96,0x04,0x21,0xB6,0xCB};

uint32_t GreekRisk::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->delta);
          this->__isset.delta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->gamma);
          this->__isset.gamma = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->theta);
          this->__isset.theta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vega);
          this->__isset.vega = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GreekRisk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("GreekRisk");

  xfer += oprot->writeFieldBegin("delta", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->delta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gamma", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->gamma);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("theta", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->theta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->vega);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(GreekRisk &a, GreekRisk &b) {
  using ::std::swap;
  swap(a.delta, b.delta);
  swap(a.gamma, b.gamma);
  swap(a.theta, b.theta);
  swap(a.vega, b.vega);
  swap(a.__isset, b.__isset);
}

GreekRisk::GreekRisk(const GreekRisk& other16) {
  delta = other16.delta;
  gamma = other16.gamma;
  theta = other16.theta;
  vega = other16.vega;
  __isset = other16.__isset;
}
GreekRisk& GreekRisk::operator=(const GreekRisk& other17) {
  delta = other17.delta;
  gamma = other17.gamma;
  theta = other17.theta;
  vega = other17.vega;
  __isset = other17.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const GreekRisk& obj) {
  using apache::thrift::to_string;
  out << "GreekRisk(";
  out << "delta=" << to_string(obj.delta);
  out << ", " << "gamma=" << to_string(obj.gamma);
  out << ", " << "theta=" << to_string(obj.theta);
  out << ", " << "vega=" << to_string(obj.vega);
  out << ")";
  return out;
}


QouteTrans::~QouteTrans() throw() {
}


void QouteTrans::__set_instr_code(const std::string& val) {
  this->instr_code = val;
}

void QouteTrans::__set_ask_price(const double val) {
  this->ask_price = val;
}

void QouteTrans::__set_ask_volume(const int32_t val) {
  this->ask_volume = val;
}

void QouteTrans::__set_bid_price(const double val) {
  this->bid_price = val;
}

void QouteTrans::__set_bid_volume(const int32_t val) {
  this->bid_volume = val;
}

const char* QouteTrans::ascii_fingerprint = "72F44F217EA4AD9725E7AE3C1415175F";
const uint8_t QouteTrans::binary_fingerprint[16] = {0x72,0xF4,0x4F,0x21,0x7E,0xA4,0xAD,0x97,0x25,0xE7,0xAE,0x3C,0x14,0x15,0x17,0x5F};

uint32_t QouteTrans::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instr_code);
          this->__isset.instr_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ask_price);
          this->__isset.ask_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ask_volume);
          this->__isset.ask_volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bid_price);
          this->__isset.bid_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid_volume);
          this->__isset.bid_volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QouteTrans::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("QouteTrans");

  xfer += oprot->writeFieldBegin("instr_code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instr_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ask_price", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->ask_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ask_volume", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ask_volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid_price", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->bid_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid_volume", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->bid_volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(QouteTrans &a, QouteTrans &b) {
  using ::std::swap;
  swap(a.instr_code, b.instr_code);
  swap(a.ask_price, b.ask_price);
  swap(a.ask_volume, b.ask_volume);
  swap(a.bid_price, b.bid_price);
  swap(a.bid_volume, b.bid_volume);
  swap(a.__isset, b.__isset);
}

QouteTrans::QouteTrans(const QouteTrans& other18) {
  instr_code = other18.instr_code;
  ask_price = other18.ask_price;
  ask_volume = other18.ask_volume;
  bid_price = other18.bid_price;
  bid_volume = other18.bid_volume;
  __isset = other18.__isset;
}
QouteTrans& QouteTrans::operator=(const QouteTrans& other19) {
  instr_code = other19.instr_code;
  ask_price = other19.ask_price;
  ask_volume = other19.ask_volume;
  bid_price = other19.bid_price;
  bid_volume = other19.bid_volume;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const QouteTrans& obj) {
  using apache::thrift::to_string;
  out << "QouteTrans(";
  out << "instr_code=" << to_string(obj.instr_code);
  out << ", " << "ask_price=" << to_string(obj.ask_price);
  out << ", " << "ask_volume=" << to_string(obj.ask_volume);
  out << ", " << "bid_price=" << to_string(obj.bid_price);
  out << ", " << "bid_volume=" << to_string(obj.bid_volume);
  out << ")";
  return out;
}


InvalidQuery::~InvalidQuery() throw() {
}


void InvalidQuery::__set_what(const int32_t val) {
  this->what = val;
}

void InvalidQuery::__set_why(const std::string& val) {
  this->why = val;
}

const char* InvalidQuery::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t InvalidQuery::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t InvalidQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what);
          this->__isset.what = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("InvalidQuery");

  xfer += oprot->writeFieldBegin("what", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->what);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(InvalidQuery &a, InvalidQuery &b) {
  using ::std::swap;
  swap(a.what, b.what);
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

InvalidQuery::InvalidQuery(const InvalidQuery& other20) : TException() {
  what = other20.what;
  why = other20.why;
  __isset = other20.__isset;
}
InvalidQuery& InvalidQuery::operator=(const InvalidQuery& other21) {
  what = other21.what;
  why = other21.why;
  __isset = other21.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const InvalidQuery& obj) {
  using apache::thrift::to_string;
  out << "InvalidQuery(";
  out << "what=" << to_string(obj.what);
  out << ", " << "why=" << to_string(obj.why);
  out << ")";
  return out;
}


