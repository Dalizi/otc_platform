/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ClientService.h"
#include "thrift/async/TAsyncChannel.h"




ClientService_auth_args::~ClientService_auth_args() throw() {
}


uint32_t ClientService_auth_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_auth_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_auth_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_auth_pargs::~ClientService_auth_pargs() throw() {
}


uint32_t ClientService_auth_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_auth_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->password)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_auth_result::~ClientService_auth_result() throw() {
}


uint32_t ClientService_auth_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_auth_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_auth_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_auth_presult::~ClientService_auth_presult() throw() {
}


uint32_t ClientService_auth_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_auth_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_auth_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_pnl_args::~ClientService_get_pnl_args() throw() {
}


uint32_t ClientService_get_pnl_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ptt.read(iprot);
          this->__isset.ptt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_pnl_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_pnl_args");

  xfer += oprot->writeFieldBegin("ptt", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ptt.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_pnl_pargs::~ClientService_get_pnl_pargs() throw() {
}


uint32_t ClientService_get_pnl_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_pnl_pargs");

  xfer += oprot->writeFieldBegin("ptt", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->ptt)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_pnl_result::~ClientService_get_pnl_result() throw() {
}


uint32_t ClientService_get_pnl_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_pnl_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_pnl_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_pnl_presult::~ClientService_get_pnl_presult() throw() {
}


uint32_t ClientService_get_pnl_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_pnl_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_pnl_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
  xfer += oprot->writeDouble((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_close_price_args::~ClientService_get_close_price_args() throw() {
}


uint32_t ClientService_get_close_price_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ptt.read(iprot);
          this->__isset.ptt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_close_price_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_close_price_args");

  xfer += oprot->writeFieldBegin("ptt", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ptt.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_close_price_pargs::~ClientService_get_close_price_pargs() throw() {
}


uint32_t ClientService_get_close_price_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_close_price_pargs");

  xfer += oprot->writeFieldBegin("ptt", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->ptt)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_close_price_result::~ClientService_get_close_price_result() throw() {
}


uint32_t ClientService_get_close_price_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_close_price_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_close_price_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_close_price_presult::~ClientService_get_close_price_presult() throw() {
}


uint32_t ClientService_get_close_price_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_close_price_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_close_price_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
  xfer += oprot->writeDouble((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_calculated_balance_args::~ClientService_get_calculated_balance_args() throw() {
}


uint32_t ClientService_get_calculated_balance_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_calculated_balance_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_calculated_balance_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_calculated_balance_pargs::~ClientService_get_calculated_balance_pargs() throw() {
}


uint32_t ClientService_get_calculated_balance_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_calculated_balance_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_calculated_balance_result::~ClientService_get_calculated_balance_result() throw() {
}


uint32_t ClientService_get_calculated_balance_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              std::string _key27;
              xfer += iprot->readString(_key27);
              double& _val28 = this->success[_key27];
              xfer += iprot->readDouble(_val28);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_calculated_balance_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_calculated_balance_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, double> ::const_iterator _iter29;
      for (_iter29 = this->success.begin(); _iter29 != this->success.end(); ++_iter29)
      {
        xfer += oprot->writeString(_iter29->first);
        xfer += oprot->writeDouble(_iter29->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_calculated_balance_presult::~ClientService_get_calculated_balance_presult() throw() {
}


uint32_t ClientService_get_calculated_balance_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              std::string _key35;
              xfer += iprot->readString(_key35);
              double& _val36 = (*(this->success))[_key35];
              xfer += iprot->readDouble(_val36);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_calculated_balance_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_calculated_balance_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, double> ::const_iterator _iter37;
    for (_iter37 = (*(this->success)).begin(); _iter37 != (*(this->success)).end(); ++_iter37)
    {
      xfer += oprot->writeString(_iter37->first);
      xfer += oprot->writeDouble(_iter37->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_greeks_args::~ClientService_get_greeks_args() throw() {
}


uint32_t ClientService_get_greeks_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_greeks_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_greeks_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_greeks_pargs::~ClientService_get_greeks_pargs() throw() {
}


uint32_t ClientService_get_greeks_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_greeks_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_greeks_result::~ClientService_get_greeks_result() throw() {
}


uint32_t ClientService_get_greeks_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_greeks_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_greeks_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_greeks_presult::~ClientService_get_greeks_presult() throw() {
}


uint32_t ClientService_get_greeks_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_greeks_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_greeks_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_client_greeks_args::~ClientService_get_client_greeks_args() throw() {
}


uint32_t ClientService_get_client_greeks_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_client_greeks_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_client_greeks_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_client_greeks_pargs::~ClientService_get_client_greeks_pargs() throw() {
}


uint32_t ClientService_get_client_greeks_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_client_greeks_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_client_greeks_result::~ClientService_get_client_greeks_result() throw() {
}


uint32_t ClientService_get_client_greeks_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_client_greeks_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_client_greeks_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_client_greeks_presult::~ClientService_get_client_greeks_presult() throw() {
}


uint32_t ClientService_get_client_greeks_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_client_greeks_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_client_greeks_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_update_hedge_position_args::~ClientService_update_hedge_position_args() throw() {
}


uint32_t ClientService_update_hedge_position_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ptt.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->ptt.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->ptt[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ptt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_update_hedge_position_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_update_hedge_position_args");

  xfer += oprot->writeFieldBegin("ptt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ptt.size()));
    std::vector<PositionTypeTrans> ::const_iterator _iter43;
    for (_iter43 = this->ptt.begin(); _iter43 != this->ptt.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_update_hedge_position_pargs::~ClientService_update_hedge_position_pargs() throw() {
}


uint32_t ClientService_update_hedge_position_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_update_hedge_position_pargs");

  xfer += oprot->writeFieldBegin("ptt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->ptt)).size()));
    std::vector<PositionTypeTrans> ::const_iterator _iter44;
    for (_iter44 = (*(this->ptt)).begin(); _iter44 != (*(this->ptt)).end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_update_hedge_position_result::~ClientService_update_hedge_position_result() throw() {
}


uint32_t ClientService_update_hedge_position_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_update_hedge_position_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_update_hedge_position_result");

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_update_hedge_position_presult::~ClientService_update_hedge_position_presult() throw() {
}


uint32_t ClientService_update_hedge_position_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_update_hedge_position_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_update_hedge_position_presult");

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_place_order_args::~ClientService_place_order_args() throw() {
}


uint32_t ClientService_place_order_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->order.read(iprot);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_place_order_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_place_order_args");

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->order.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_place_order_pargs::~ClientService_place_order_pargs() throw() {
}


uint32_t ClientService_place_order_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_place_order_pargs");

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->order)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_order_args::~ClientService_get_order_args() throw() {
}


uint32_t ClientService_get_order_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_date);
          this->__isset.start_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_date);
          this->__isset.end_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_order_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_order_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_date", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->start_date);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_date", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->end_date);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_order_pargs::~ClientService_get_order_pargs() throw() {
}


uint32_t ClientService_get_order_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_order_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_date", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->start_date)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_date", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->end_date)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_order_result::~ClientService_get_order_result() throw() {
}


uint32_t ClientService_get_order_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->success.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->success[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_order_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_order_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<OrderTypeTrans> ::const_iterator _iter50;
      for (_iter50 = this->success.begin(); _iter50 != this->success.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_order_presult::~ClientService_get_order_presult() throw() {
}


uint32_t ClientService_get_order_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            (*(this->success)).resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += (*(this->success))[_i55].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_order_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_order_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<OrderTypeTrans> ::const_iterator _iter56;
    for (_iter56 = (*(this->success)).begin(); _iter56 != (*(this->success)).end(); ++_iter56)
    {
      xfer += (*_iter56).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_transaction_args::~ClientService_get_transaction_args() throw() {
}


uint32_t ClientService_get_transaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_date);
          this->__isset.start_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_date);
          this->__isset.end_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_transaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_transaction_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_date", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->start_date);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_date", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->end_date);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_transaction_pargs::~ClientService_get_transaction_pargs() throw() {
}


uint32_t ClientService_get_transaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_transaction_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_date", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->start_date)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_date", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->end_date)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_transaction_result::~ClientService_get_transaction_result() throw() {
}


uint32_t ClientService_get_transaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->success.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->success[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_transaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_transaction_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<TransactionTypeTrans> ::const_iterator _iter62;
      for (_iter62 = this->success.begin(); _iter62 != this->success.end(); ++_iter62)
      {
        xfer += (*_iter62).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_transaction_presult::~ClientService_get_transaction_presult() throw() {
}


uint32_t ClientService_get_transaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            (*(this->success)).resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += (*(this->success))[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_transaction_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_transaction_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<TransactionTypeTrans> ::const_iterator _iter68;
    for (_iter68 = (*(this->success)).begin(); _iter68 != (*(this->success)).end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_position_args::~ClientService_get_position_args() throw() {
}


uint32_t ClientService_get_position_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_position_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_position_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_position_pargs::~ClientService_get_position_pargs() throw() {
}


uint32_t ClientService_get_position_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_position_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_position_result::~ClientService_get_position_result() throw() {
}


uint32_t ClientService_get_position_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->success.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->success[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_position_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_position_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<PositionTypeTrans> ::const_iterator _iter74;
      for (_iter74 = this->success.begin(); _iter74 != this->success.end(); ++_iter74)
      {
        xfer += (*_iter74).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_position_presult::~ClientService_get_position_presult() throw() {
}


uint32_t ClientService_get_position_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            (*(this->success)).resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += (*(this->success))[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_position_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_position_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<PositionTypeTrans> ::const_iterator _iter80;
    for (_iter80 = (*(this->success)).begin(); _iter80 != (*(this->success)).end(); ++_iter80)
    {
      xfer += (*_iter80).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_balance_args::~ClientService_get_balance_args() throw() {
}


uint32_t ClientService_get_balance_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_balance_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_balance_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_balance_pargs::~ClientService_get_balance_pargs() throw() {
}


uint32_t ClientService_get_balance_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_balance_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_balance_result::~ClientService_get_balance_result() throw() {
}


uint32_t ClientService_get_balance_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_balance_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_balance_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_balance_presult::~ClientService_get_balance_presult() throw() {
}


uint32_t ClientService_get_balance_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_balance_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_balance_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_clientinfo_args::~ClientService_get_clientinfo_args() throw() {
}


uint32_t ClientService_get_clientinfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_clientinfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_clientinfo_args");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->client_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_clientinfo_pargs::~ClientService_get_clientinfo_pargs() throw() {
}


uint32_t ClientService_get_clientinfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_clientinfo_pargs");

  xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->client_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_clientinfo_result::~ClientService_get_clientinfo_result() throw() {
}


uint32_t ClientService_get_clientinfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_clientinfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_clientinfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_clientinfo_presult::~ClientService_get_clientinfo_presult() throw() {
}


uint32_t ClientService_get_clientinfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_clientinfo_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_clientinfo_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_qoute_args::~ClientService_get_qoute_args() throw() {
}


uint32_t ClientService_get_qoute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_qoute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_qoute_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_qoute_pargs::~ClientService_get_qoute_pargs() throw() {
}


uint32_t ClientService_get_qoute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_qoute_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}


ClientService_get_qoute_result::~ClientService_get_qoute_result() throw() {
}


uint32_t ClientService_get_qoute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readListBegin(_etype84, _size81);
            this->success.resize(_size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              xfer += this->success[_i85].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_qoute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientService_get_qoute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<QouteTrans> ::const_iterator _iter86;
      for (_iter86 = this->success.begin(); _iter86 != this->success.end(); ++_iter86)
      {
        xfer += (*_iter86).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientService_get_qoute_presult::~ClientService_get_qoute_presult() throw() {
}


uint32_t ClientService_get_qoute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            (*(this->success)).resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += (*(this->success))[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iq.read(iprot);
          this->__isset.iq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientService_get_qoute_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientService_get_qoute_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<QouteTrans> ::const_iterator _iter92;
    for (_iter92 = (*(this->success)).begin(); _iter92 != (*(this->success)).end(); ++_iter92)
    {
      xfer += (*_iter92).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iq) {
    xfer += oprot->writeFieldBegin("iq", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->iq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

bool ClientServiceClient::auth(const std::string& client_id, const std::string& password)
{
  send_auth(client_id, password);
  return recv_auth();
}

void ClientServiceClient::send_auth(const std::string& client_id, const std::string& password)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("auth", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_auth_pargs args;
  args.client_id = &client_id;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientServiceClient::recv_auth()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("auth") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientService_auth_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "auth failed: unknown result");
}

double ClientServiceClient::get_pnl(const PositionTypeTrans& ptt)
{
  send_get_pnl(ptt);
  return recv_get_pnl();
}

void ClientServiceClient::send_get_pnl(const PositionTypeTrans& ptt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_pnl_pargs args;
  args.ptt = &ptt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double ClientServiceClient::recv_get_pnl()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_pnl") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  ClientService_get_pnl_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_pnl failed: unknown result");
}

double ClientServiceClient::get_close_price(const PositionTypeTrans& ptt)
{
  send_get_close_price(ptt);
  return recv_get_close_price();
}

void ClientServiceClient::send_get_close_price(const PositionTypeTrans& ptt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_close_price_pargs args;
  args.ptt = &ptt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double ClientServiceClient::recv_get_close_price()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_close_price") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  ClientService_get_close_price_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_close_price failed: unknown result");
}

void ClientServiceClient::get_calculated_balance(std::map<std::string, double> & _return, const int32_t client_id)
{
  send_get_calculated_balance(client_id);
  recv_get_calculated_balance(_return);
}

void ClientServiceClient::send_get_calculated_balance(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_calculated_balance_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_calculated_balance(std::map<std::string, double> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_calculated_balance") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_calculated_balance_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_calculated_balance failed: unknown result");
}

void ClientServiceClient::get_greeks(GreekRisk& _return)
{
  send_get_greeks();
  recv_get_greeks(_return);
}

void ClientServiceClient::send_get_greeks()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_greeks_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_greeks(GreekRisk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_greeks") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_greeks_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_greeks failed: unknown result");
}

void ClientServiceClient::get_client_greeks(GreekRisk& _return, const int32_t client_id)
{
  send_get_client_greeks(client_id);
  recv_get_client_greeks(_return);
}

void ClientServiceClient::send_get_client_greeks(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_client_greeks_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_client_greeks(GreekRisk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_client_greeks") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_client_greeks_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_client_greeks failed: unknown result");
}

void ClientServiceClient::update_hedge_position(const std::vector<PositionTypeTrans> & ptt)
{
  send_update_hedge_position(ptt);
  recv_update_hedge_position();
}

void ClientServiceClient::send_update_hedge_position(const std::vector<PositionTypeTrans> & ptt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_update_hedge_position_pargs args;
  args.ptt = &ptt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_update_hedge_position()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("update_hedge_position") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_update_hedge_position_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.iq) {
    throw result.iq;
  }
  return;
}

void ClientServiceClient::place_order(const OrderTypeTrans& order)
{
  send_place_order(order);
}

void ClientServiceClient::send_place_order(const OrderTypeTrans& order)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("place_order", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientService_place_order_pargs args;
  args.order = &order;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::get_order(std::vector<OrderTypeTrans> & _return, const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  send_get_order(client_id, start_date, end_date);
  recv_get_order(_return);
}

void ClientServiceClient::send_get_order(const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_order", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_order_pargs args;
  args.client_id = &client_id;
  args.start_date = &start_date;
  args.end_date = &end_date;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_order(std::vector<OrderTypeTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_order") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_order_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_order failed: unknown result");
}

void ClientServiceClient::get_transaction(std::vector<TransactionTypeTrans> & _return, const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  send_get_transaction(client_id, start_date, end_date);
  recv_get_transaction(_return);
}

void ClientServiceClient::send_get_transaction(const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_transaction_pargs args;
  args.client_id = &client_id;
  args.start_date = &start_date;
  args.end_date = &end_date;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_transaction(std::vector<TransactionTypeTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_transaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_transaction_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_transaction failed: unknown result");
}

void ClientServiceClient::get_position(std::vector<PositionTypeTrans> & _return, const int32_t client_id)
{
  send_get_position(client_id);
  recv_get_position(_return);
}

void ClientServiceClient::send_get_position(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_position", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_position_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_position(std::vector<PositionTypeTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_position") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_position_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_position failed: unknown result");
}

void ClientServiceClient::get_balance(ClientBalanceTrans& _return, const int32_t client_id)
{
  send_get_balance(client_id);
  recv_get_balance(_return);
}

void ClientServiceClient::send_get_balance(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_balance_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_balance(ClientBalanceTrans& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_balance") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_balance_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_balance failed: unknown result");
}

void ClientServiceClient::get_clientinfo(ClientInfoTrans& _return, const int32_t client_id)
{
  send_get_clientinfo(client_id);
  recv_get_clientinfo(_return);
}

void ClientServiceClient::send_get_clientinfo(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_clientinfo_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_clientinfo(ClientInfoTrans& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_clientinfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_clientinfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_clientinfo failed: unknown result");
}

void ClientServiceClient::get_qoute(std::vector<QouteTrans> & _return)
{
  send_get_qoute();
  recv_get_qoute(_return);
}

void ClientServiceClient::send_get_qoute()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_qoute_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceClient::recv_get_qoute(std::vector<QouteTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_qoute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientService_get_qoute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.iq) {
    throw result.iq;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_qoute failed: unknown result");
}

bool ClientServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void ClientServiceProcessor::process_auth(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.auth", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.auth");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.auth");
  }

  ClientService_auth_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.auth", bytes);
  }

  ClientService_auth_result result;
  try {
    result.success = iface_->auth(args.client_id, args.password);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.auth");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("auth", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.auth");
  }

  oprot->writeMessageBegin("auth", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.auth", bytes);
  }
}

void ClientServiceProcessor::process_get_pnl(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_pnl", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_pnl");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_pnl");
  }

  ClientService_get_pnl_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_pnl", bytes);
  }

  ClientService_get_pnl_result result;
  try {
    result.success = iface_->get_pnl(args.ptt);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_pnl");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_pnl");
  }

  oprot->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_pnl", bytes);
  }
}

void ClientServiceProcessor::process_get_close_price(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_close_price", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_close_price");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_close_price");
  }

  ClientService_get_close_price_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_close_price", bytes);
  }

  ClientService_get_close_price_result result;
  try {
    result.success = iface_->get_close_price(args.ptt);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_close_price");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_close_price");
  }

  oprot->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_close_price", bytes);
  }
}

void ClientServiceProcessor::process_get_calculated_balance(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_calculated_balance", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_calculated_balance");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_calculated_balance");
  }

  ClientService_get_calculated_balance_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_calculated_balance", bytes);
  }

  ClientService_get_calculated_balance_result result;
  try {
    iface_->get_calculated_balance(result.success, args.client_id);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_calculated_balance");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_calculated_balance");
  }

  oprot->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_calculated_balance", bytes);
  }
}

void ClientServiceProcessor::process_get_greeks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_greeks", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_greeks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_greeks");
  }

  ClientService_get_greeks_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_greeks", bytes);
  }

  ClientService_get_greeks_result result;
  try {
    iface_->get_greeks(result.success);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_greeks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_greeks");
  }

  oprot->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_greeks", bytes);
  }
}

void ClientServiceProcessor::process_get_client_greeks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_client_greeks", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_client_greeks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_client_greeks");
  }

  ClientService_get_client_greeks_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_client_greeks", bytes);
  }

  ClientService_get_client_greeks_result result;
  try {
    iface_->get_client_greeks(result.success, args.client_id);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_client_greeks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_client_greeks");
  }

  oprot->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_client_greeks", bytes);
  }
}

void ClientServiceProcessor::process_update_hedge_position(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.update_hedge_position", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.update_hedge_position");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.update_hedge_position");
  }

  ClientService_update_hedge_position_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.update_hedge_position", bytes);
  }

  ClientService_update_hedge_position_result result;
  try {
    iface_->update_hedge_position(args.ptt);
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.update_hedge_position");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.update_hedge_position");
  }

  oprot->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.update_hedge_position", bytes);
  }
}

void ClientServiceProcessor::process_place_order(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.place_order", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.place_order");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.place_order");
  }

  ClientService_place_order_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.place_order", bytes);
  }

  try {
    iface_->place_order(args.order);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.place_order");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ClientService.place_order");
  }

  return;
}

void ClientServiceProcessor::process_get_order(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_order", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_order");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_order");
  }

  ClientService_get_order_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_order", bytes);
  }

  ClientService_get_order_result result;
  try {
    iface_->get_order(result.success, args.client_id, args.start_date, args.end_date);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_order");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_order", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_order");
  }

  oprot->writeMessageBegin("get_order", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_order", bytes);
  }
}

void ClientServiceProcessor::process_get_transaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_transaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_transaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_transaction");
  }

  ClientService_get_transaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_transaction", bytes);
  }

  ClientService_get_transaction_result result;
  try {
    iface_->get_transaction(result.success, args.client_id, args.start_date, args.end_date);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_transaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_transaction");
  }

  oprot->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_transaction", bytes);
  }
}

void ClientServiceProcessor::process_get_position(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_position", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_position");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_position");
  }

  ClientService_get_position_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_position", bytes);
  }

  ClientService_get_position_result result;
  try {
    iface_->get_position(result.success, args.client_id);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_position");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_position", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_position");
  }

  oprot->writeMessageBegin("get_position", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_position", bytes);
  }
}

void ClientServiceProcessor::process_get_balance(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_balance", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_balance");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_balance");
  }

  ClientService_get_balance_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_balance", bytes);
  }

  ClientService_get_balance_result result;
  try {
    iface_->get_balance(result.success, args.client_id);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_balance");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_balance");
  }

  oprot->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_balance", bytes);
  }
}

void ClientServiceProcessor::process_get_clientinfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_clientinfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_clientinfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_clientinfo");
  }

  ClientService_get_clientinfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_clientinfo", bytes);
  }

  ClientService_get_clientinfo_result result;
  try {
    iface_->get_clientinfo(result.success, args.client_id);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_clientinfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_clientinfo");
  }

  oprot->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_clientinfo", bytes);
  }
}

void ClientServiceProcessor::process_get_qoute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_qoute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_qoute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ClientService.get_qoute");
  }

  ClientService_get_qoute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ClientService.get_qoute", bytes);
  }

  ClientService_get_qoute_result result;
  try {
    iface_->get_qoute(result.success);
    result.__isset.success = true;
  } catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_qoute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_qoute");
  }

  oprot->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_qoute", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > ClientServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ClientServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< ClientServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new ClientServiceProcessor(handler));
  return processor;
}
void ClientServiceCobClient::auth(tcxx::function<void(ClientServiceCobClient* client)> cob, const std::string& client_id, const std::string& password)
{
  send_auth(client_id, password);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_auth(const std::string& client_id, const std::string& password)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("auth", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_auth_pargs args;
  args.client_id = &client_id;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientServiceCobClient::recv_auth()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("auth") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    ClientService_auth_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "auth failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_pnl(tcxx::function<void(ClientServiceCobClient* client)> cob, const PositionTypeTrans& ptt)
{
  send_get_pnl(ptt);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_pnl(const PositionTypeTrans& ptt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_pnl_pargs args;
  args.ptt = &ptt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double ClientServiceCobClient::recv_get_pnl()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_pnl") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    double _return;
    ClientService_get_pnl_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_pnl failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_close_price(tcxx::function<void(ClientServiceCobClient* client)> cob, const PositionTypeTrans& ptt)
{
  send_get_close_price(ptt);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_close_price(const PositionTypeTrans& ptt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_close_price_pargs args;
  args.ptt = &ptt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double ClientServiceCobClient::recv_get_close_price()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_close_price") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    double _return;
    ClientService_get_close_price_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_close_price failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_calculated_balance(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id)
{
  send_get_calculated_balance(client_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_calculated_balance(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_calculated_balance_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_calculated_balance(std::map<std::string, double> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_calculated_balance") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_calculated_balance_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_calculated_balance failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_greeks(tcxx::function<void(ClientServiceCobClient* client)> cob)
{
  send_get_greeks();
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_greeks()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_greeks_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_greeks(GreekRisk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_greeks") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_greeks_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_greeks failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_client_greeks(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id)
{
  send_get_client_greeks(client_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_client_greeks(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_client_greeks_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_client_greeks(GreekRisk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_client_greeks") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_client_greeks_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_client_greeks failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::update_hedge_position(tcxx::function<void(ClientServiceCobClient* client)> cob, const std::vector<PositionTypeTrans> & ptt)
{
  send_update_hedge_position(ptt);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_update_hedge_position(const std::vector<PositionTypeTrans> & ptt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_update_hedge_position_pargs args;
  args.ptt = &ptt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_update_hedge_position()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("update_hedge_position") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_update_hedge_position_presult result;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::place_order(tcxx::function<void(ClientServiceCobClient* client)> cob, const OrderTypeTrans& order)
{
  send_place_order(order);
  channel_->sendMessage(tcxx::bind(cob, this), otrans_.get());
}

void ClientServiceCobClient::send_place_order(const OrderTypeTrans& order)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("place_order", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientService_place_order_pargs args;
  args.order = &order;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::get_order(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  send_get_order(client_id, start_date, end_date);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_order(const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_order", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_order_pargs args;
  args.client_id = &client_id;
  args.start_date = &start_date;
  args.end_date = &end_date;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_order(std::vector<OrderTypeTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_order") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_order_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_order failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_transaction(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  send_get_transaction(client_id, start_date, end_date);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_transaction(const int32_t client_id, const std::string& start_date, const std::string& end_date)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_transaction_pargs args;
  args.client_id = &client_id;
  args.start_date = &start_date;
  args.end_date = &end_date;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_transaction(std::vector<TransactionTypeTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_transaction") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_transaction_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_transaction failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_position(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id)
{
  send_get_position(client_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_position(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_position", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_position_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_position(std::vector<PositionTypeTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_position") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_position_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_position failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_balance(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id)
{
  send_get_balance(client_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_balance(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_balance_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_balance(ClientBalanceTrans& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_balance") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_balance_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_balance failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_clientinfo(tcxx::function<void(ClientServiceCobClient* client)> cob, const int32_t client_id)
{
  send_get_clientinfo(client_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_clientinfo(const int32_t client_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_clientinfo_pargs args;
  args.client_id = &client_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_clientinfo(ClientInfoTrans& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_clientinfo") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_clientinfo_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_clientinfo failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceCobClient::get_qoute(tcxx::function<void(ClientServiceCobClient* client)> cob)
{
  send_get_qoute();
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void ClientServiceCobClient::send_get_qoute()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientService_get_qoute_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientServiceCobClient::recv_get_qoute(std::vector<QouteTrans> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_qoute") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ClientService_get_qoute_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.iq) {
      completed = true;
      completed__(true);
      throw result.iq;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_qoute failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void ClientServiceAsyncProcessor::dispatchCall(tcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second))(cob, seqid, iprot, oprot);
  return;
}

void ClientServiceAsyncProcessor::process_auth(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_auth_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.auth", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.auth");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.auth");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.auth", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.auth");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &ClientServiceAsyncProcessor::return_auth;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_auth;
  iface_->auth(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id,
      args.password);
}

void ClientServiceAsyncProcessor::return_auth(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  ClientService_auth_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.auth", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.auth");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.auth");
  }

  oprot->writeMessageBegin("auth", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.auth", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_auth(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.auth", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.auth");

  ClientService_auth_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.auth");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("auth", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.auth");
  }

  oprot->writeMessageBegin("auth", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.auth", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_pnl(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_pnl_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_pnl", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_pnl");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_pnl");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_pnl", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_pnl");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return) =
    &ClientServiceAsyncProcessor::return_get_pnl;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_pnl;
  iface_->get_pnl(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.ptt);
}

void ClientServiceAsyncProcessor::return_get_pnl(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return)
{
  ClientService_get_pnl_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_pnl", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_pnl");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_pnl");
  }

  oprot->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_pnl", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_pnl(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_pnl", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_pnl");

  ClientService_get_pnl_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_pnl");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_pnl");
  }

  oprot->writeMessageBegin("get_pnl", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_pnl", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_close_price(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_close_price_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_close_price", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_close_price");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_close_price");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_close_price", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_close_price");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return) =
    &ClientServiceAsyncProcessor::return_get_close_price;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_close_price;
  iface_->get_close_price(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.ptt);
}

void ClientServiceAsyncProcessor::return_get_close_price(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return)
{
  ClientService_get_close_price_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_close_price", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_close_price");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_close_price");
  }

  oprot->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_close_price", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_close_price(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_close_price", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_close_price");

  ClientService_get_close_price_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_close_price");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_close_price");
  }

  oprot->writeMessageBegin("get_close_price", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_close_price", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_calculated_balance(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_calculated_balance_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_calculated_balance", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_calculated_balance");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_calculated_balance");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_calculated_balance", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_calculated_balance");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, double> & _return) =
    &ClientServiceAsyncProcessor::return_get_calculated_balance;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_calculated_balance;
  iface_->get_calculated_balance(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id);
}

void ClientServiceAsyncProcessor::return_get_calculated_balance(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, double> & _return)
{
  ClientService_get_calculated_balance_presult result;
  result.success = const_cast<std::map<std::string, double> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_calculated_balance", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_calculated_balance");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_calculated_balance");
  }

  oprot->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_calculated_balance", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_calculated_balance(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_calculated_balance", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_calculated_balance");

  ClientService_get_calculated_balance_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_calculated_balance");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_calculated_balance");
  }

  oprot->writeMessageBegin("get_calculated_balance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_calculated_balance", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_greeks(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_greeks_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_greeks", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_greeks");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_greeks");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_greeks", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_greeks");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const GreekRisk& _return) =
    &ClientServiceAsyncProcessor::return_get_greeks;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_greeks;
  iface_->get_greeks(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1));
}

void ClientServiceAsyncProcessor::return_get_greeks(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const GreekRisk& _return)
{
  ClientService_get_greeks_presult result;
  result.success = const_cast<GreekRisk*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_greeks", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_greeks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_greeks");
  }

  oprot->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_greeks", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_greeks(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_greeks", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_greeks");

  ClientService_get_greeks_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_greeks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_greeks");
  }

  oprot->writeMessageBegin("get_greeks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_greeks", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_client_greeks(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_client_greeks_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_client_greeks", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_client_greeks");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_client_greeks");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_client_greeks", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_client_greeks");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const GreekRisk& _return) =
    &ClientServiceAsyncProcessor::return_get_client_greeks;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_client_greeks;
  iface_->get_client_greeks(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id);
}

void ClientServiceAsyncProcessor::return_get_client_greeks(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const GreekRisk& _return)
{
  ClientService_get_client_greeks_presult result;
  result.success = const_cast<GreekRisk*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_client_greeks", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_client_greeks");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_client_greeks");
  }

  oprot->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_client_greeks", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_client_greeks(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_client_greeks", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_client_greeks");

  ClientService_get_client_greeks_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_client_greeks");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_client_greeks");
  }

  oprot->writeMessageBegin("get_client_greeks", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_client_greeks", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_update_hedge_position(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_update_hedge_position_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.update_hedge_position", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.update_hedge_position");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.update_hedge_position");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.update_hedge_position", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.update_hedge_position");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ClientServiceAsyncProcessor::return_update_hedge_position;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_update_hedge_position;
  iface_->update_hedge_position(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.ptt);
}

void ClientServiceAsyncProcessor::return_update_hedge_position(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  ClientService_update_hedge_position_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.update_hedge_position", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.update_hedge_position");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.update_hedge_position");
  }

  oprot->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.update_hedge_position", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_update_hedge_position(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.update_hedge_position", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.update_hedge_position");

  ClientService_update_hedge_position_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.update_hedge_position");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.update_hedge_position");
  }

  oprot->writeMessageBegin("update_hedge_position", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.update_hedge_position", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_place_order(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  (void) seqid;
  (void) oprot;
  ClientService_place_order_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.place_order", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.place_order");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.place_order");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.place_order", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.place_order");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ClientService.place_order");
  }
  freer.unregister();
  iface_->place_order(tcxx::bind(cob, true)
,
      args.order);
}

void ClientServiceAsyncProcessor::process_get_order(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_order_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_order", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_order");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_order");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_order", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_order");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<OrderTypeTrans> & _return) =
    &ClientServiceAsyncProcessor::return_get_order;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_order;
  iface_->get_order(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id,
      args.start_date,
      args.end_date);
}

void ClientServiceAsyncProcessor::return_get_order(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<OrderTypeTrans> & _return)
{
  ClientService_get_order_presult result;
  result.success = const_cast<std::vector<OrderTypeTrans> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_order", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_order");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_order");
  }

  oprot->writeMessageBegin("get_order", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_order", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_order(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_order", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_order");

  ClientService_get_order_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_order");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_order", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_order");
  }

  oprot->writeMessageBegin("get_order", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_order", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_transaction(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_transaction_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_transaction", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_transaction");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_transaction");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_transaction", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_transaction");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<TransactionTypeTrans> & _return) =
    &ClientServiceAsyncProcessor::return_get_transaction;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_transaction;
  iface_->get_transaction(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id,
      args.start_date,
      args.end_date);
}

void ClientServiceAsyncProcessor::return_get_transaction(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<TransactionTypeTrans> & _return)
{
  ClientService_get_transaction_presult result;
  result.success = const_cast<std::vector<TransactionTypeTrans> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_transaction", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_transaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_transaction");
  }

  oprot->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_transaction", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_transaction(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_transaction", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_transaction");

  ClientService_get_transaction_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_transaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_transaction");
  }

  oprot->writeMessageBegin("get_transaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_transaction", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_position(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_position_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_position", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_position");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_position");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_position", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_position");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<PositionTypeTrans> & _return) =
    &ClientServiceAsyncProcessor::return_get_position;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_position;
  iface_->get_position(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id);
}

void ClientServiceAsyncProcessor::return_get_position(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<PositionTypeTrans> & _return)
{
  ClientService_get_position_presult result;
  result.success = const_cast<std::vector<PositionTypeTrans> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_position", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_position");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_position");
  }

  oprot->writeMessageBegin("get_position", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_position", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_position(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_position", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_position");

  ClientService_get_position_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_position");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_position", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_position");
  }

  oprot->writeMessageBegin("get_position", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_position", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_balance(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_balance_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_balance", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_balance");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_balance");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_balance", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_balance");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const ClientBalanceTrans& _return) =
    &ClientServiceAsyncProcessor::return_get_balance;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_balance;
  iface_->get_balance(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id);
}

void ClientServiceAsyncProcessor::return_get_balance(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const ClientBalanceTrans& _return)
{
  ClientService_get_balance_presult result;
  result.success = const_cast<ClientBalanceTrans*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_balance", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_balance");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_balance");
  }

  oprot->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_balance", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_balance(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_balance", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_balance");

  ClientService_get_balance_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_balance");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_balance");
  }

  oprot->writeMessageBegin("get_balance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_balance", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_clientinfo(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_clientinfo_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_clientinfo", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_clientinfo");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_clientinfo");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_clientinfo", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_clientinfo");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const ClientInfoTrans& _return) =
    &ClientServiceAsyncProcessor::return_get_clientinfo;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_clientinfo;
  iface_->get_clientinfo(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.client_id);
}

void ClientServiceAsyncProcessor::return_get_clientinfo(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const ClientInfoTrans& _return)
{
  ClientService_get_clientinfo_presult result;
  result.success = const_cast<ClientInfoTrans*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_clientinfo", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_clientinfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_clientinfo");
  }

  oprot->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_clientinfo", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_clientinfo(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_clientinfo", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_clientinfo");

  ClientService_get_clientinfo_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_clientinfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_clientinfo");
  }

  oprot->writeMessageBegin("get_clientinfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_clientinfo", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::process_get_qoute(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  ClientService_get_qoute_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_qoute", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_qoute");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ClientService.get_qoute");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ClientService.get_qoute", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_qoute");
    }
    return cob(false);
  }
  freer.unregister();
  void (ClientServiceAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<QouteTrans> & _return) =
    &ClientServiceAsyncProcessor::return_get_qoute;
  void (ClientServiceAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ClientServiceAsyncProcessor::throw_get_qoute;
  iface_->get_qoute(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1));
}

void ClientServiceAsyncProcessor::return_get_qoute(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<QouteTrans> & _return)
{
  ClientService_get_qoute_presult result;
  result.success = const_cast<std::vector<QouteTrans> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_qoute", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_qoute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_qoute");
  }

  oprot->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_qoute", bytes);
  }
  return cob(true);
}

void ClientServiceAsyncProcessor::throw_get_qoute(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ClientService.get_qoute", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientService.get_qoute");

  ClientService_get_qoute_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (InvalidQuery &iq) {
    result.iq = iq;
    result.__isset.iq = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ClientService.get_qoute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ClientService.get_qoute");
  }

  oprot->writeMessageBegin("get_qoute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ClientService.get_qoute", bytes);
  }
  return cob(true);
}

::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > ClientServiceAsyncProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ClientServiceCobSvIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< ClientServiceCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new ClientServiceAsyncProcessor(handler));
  return processor;
}


